{"version":3,"file":"utils.uts","sourceRoot":"","sources":["uni_modules/lime-date-time-picker/components/l-date-time-picker/utils.ts"],"names":[],"mappings":"AAAA,cAAc;AACd,OAAO,EAAE,cAAc,EAAE,MAAM,QAAQ,CAAC;AACxC,OAAO,EAAE,UAAU,EAAE,QAAQ,EAAE,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,WAAW,EAAE,MAAM,YAAY,CAAA;AAGxH;;;;GAIG;AACH,MAAM,UAAU,gBAAgB,CAAC,IAAI,EAAG,GAAG,GAAI,cAAc,EAAE;IAC9D,UAAU;IACV,MAAM,GAAG,EAAG,cAAc,EAAE,GAAG,EAAE,CAAC;IAElC,IAAI,KAAK,EAAC,MAAM,GAAG,CAAC,CAAC;IACrB,IAAG,OAAO,IAAI,IAAI,QAAQ,EAAE;QAC3B,QAAQ,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,GAAG,EAAE,EAAE;YAC/B,IAAG,CAAC,IAAI,IAAI,MAAM,CAAC,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBAClC,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;aACtB;QACF,CAAC,CAAC,CAAA;KACF;SAAM,IAAG,OAAO,IAAI,IAAI,QAAQ,EAAE;QAClC,KAAK,GAAG,IAAI,IAAI,MAAM,CAAA;KACtB;IAED,IAAG,KAAK,IAAI,CAAC,EAAE;QACd,OAAO,GAAG,CAAA;KACV;IAGD,aAAa;IACb,MAAM,YAAY,GAAG,CAAC,SAAS,EAAE,UAAU,EAAE,SAAS,EAAE,SAAS,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;IAE7F,YAAY;IACZ,MAAM,cAAc,GAAG,YAAY,CAAC,MAAM,CAAC,CAAA,OAAO,WAAC,EAAE,CAAC,CAAC,KAAK,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;IAE9E,mBAAmB;IACnB,IAAI,cAAc,CAAC,MAAM,IAAI,CAAC,EAAE;QAC/B,OAAO,EAAE,CAAC;KACV;IAED,qBAAqB;IACrB,IAAI,eAAe,EAAG,MAAM,EAAE,GAAG,EAAE,CAAC;IACpC,IAAI,eAAe,EAAG,MAAM,EAAE,GAAG,EAAE,CAAC;IAEpC,cAAc;IACd,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;QAChC,qCAAqC;QACrC,IAAI,eAAe,CAAC,MAAM,IAAI,CAAC,IAAI,OAAO,IAAI,eAAe,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE;YAC9F,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;SAC9B;aAAM;YACN,2BAA2B;YAC3B,IAAI,eAAe,CAAC,MAAM,GAAG,eAAe,CAAC,MAAM,EAAE;gBACpD,eAAe,GAAG,eAAe,CAAC;aAClC;YACD,SAAS;YACT,eAAe,GAAG,CAAC,OAAO,CAAC,CAAC;SAC5B;IACF,CAAC,CAAC,CAAC;IAEH,iBAAiB;IACjB,IAAI,eAAe,CAAC,MAAM,GAAG,eAAe,CAAC,MAAM,EAAE;QACpD,eAAe,GAAG,eAAe,CAAC;KAClC;IAED,2BAA2B;IAC3B,OAAO,eAAe,CAAC,GAAG,CAAC,CAAA,OAAO,UAAC,EAAE,CAAC,UAAU,CAAC,YAAY,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;AAClF,CAAC","sourcesContent":["// @ts-nocheck\r\nimport { TimeModeValues } from './type';\r\nimport { MODE_NAMES, MODE_MAP, MODE_YEAR, MODE_MONTH, MODE_DATE, MODE_HOUR, MODE_MINUTE, MODE_SECOND } from './constant'\r\n\r\n\r\n/**\r\n * 根据给定的模式返回具有意义的时间列数组。\r\n * @param {number} mode - 表示时间模式的位掩码。\r\n * @returns {TimeModeValues[]} - 返回具有意义的时间列名称数组。\r\n */\r\nexport function getMeaningColumn(mode : any) : TimeModeValues[] {\r\n\t// 初始化结果数组\r\n\tconst res : TimeModeValues[] = [];\r\n\t\r\n\tlet _mode:number = 0;\r\n\tif(typeof mode == 'string') {\r\n\t\tMODE_MAP.forEach((value, key) => {\r\n\t\t\tif((mode as string).includes(key)) {\r\n\t\t\t\t_mode = _mode | value;\r\n\t\t\t}\r\n\t\t})\r\n\t} else if(typeof mode == 'number') {\r\n\t\t_mode = mode as number\r\n\t}\r\n\t\r\n\tif(_mode <= 0) {\r\n\t\treturn res\r\n\t}\r\n\t\r\n\r\n\t// 定义对应的位掩码数组\r\n\tconst modeBitmasks = [MODE_YEAR, MODE_MONTH, MODE_DATE, MODE_HOUR, MODE_MINUTE, MODE_SECOND];\r\n\r\n\t// 查找被设置的位掩码\r\n\tconst activeBitmasks = modeBitmasks.filter(bitmask => (_mode & bitmask) != 0);\r\n\r\n\t// 如果没有位掩码被设置，返回空数组\r\n\tif (activeBitmasks.length == 0) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\t// 初始化最长连续子序列和当前连续子序列\r\n\tlet longestSequence : number[] = [];\r\n\tlet currentSequence : number[] = [];\r\n\r\n\t// 遍历所有被设置的位掩码\r\n\tactiveBitmasks.forEach(bitmask => {\r\n\t\t// 如果当前序列为空或当前位掩码是前一个位掩码的两倍，则将其加入当前序列\r\n\t\tif (currentSequence.length == 0 || bitmask == currentSequence[currentSequence.length - 1] * 2) {\r\n\t\t\tcurrentSequence.push(bitmask);\r\n\t\t} else {\r\n\t\t\t// 如果当前序列长度大于最长序列长度，则更新最长序列\r\n\t\t\tif (currentSequence.length > longestSequence.length) {\r\n\t\t\t\tlongestSequence = currentSequence;\r\n\t\t\t}\r\n\t\t\t// 开始新的序列\r\n\t\t\tcurrentSequence = [bitmask];\r\n\t\t}\r\n\t});\r\n\r\n\t// 检查最后一个序列是否是最长的\r\n\tif (currentSequence.length > longestSequence.length) {\r\n\t\tlongestSequence = currentSequence;\r\n\t}\r\n\r\n\t// 将最长连续子序列的位掩码转换为对应的模式名并返回\r\n\treturn longestSequence.map(bitmask => MODE_NAMES[modeBitmasks.indexOf(bitmask)]);\r\n}"]}