{"version":3,"file":"index.uts","sourceRoot":"","sources":["uni_modules/lime-shared/getRect/index.ts"],"names":[],"mappings":"AAAA,cAAc;AAEd,6BAA6B;AAC7B,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,YAAY,CAAA;AAWhD;;GAEG;AACH,MAAM,UAAU,qBAAqB,IAAK,OAAO,CAAC,GAAG,CAAC;IACrD,OAAO,IAAI,OAAO,CAAC,CAAA,OAAO,WAAC,EAAE;QAC5B,GAAG,CAAC,mBAAmB,EAAE;aACvB,cAAc,EAAE;aAChB,YAAY,CAAC,CAAC,GAAG,EAAE,EAAE;YACrB,OAAO,CAAC,GAAG,CAAC,CAAC;QACd,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;IACZ,CAAC,CAAC,CAAA;AACH,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA6BE;AAEF,MAAM,MAAM,qBAAqB,GAAG;IACnC,0BAA0B;IAC1B,WAAY,CAAC,EAAE,MAAM,CAAC;IACtB,0BAA0B;IAC1B,SAAU,CAAC,EAAE,MAAM,CAAC;IACpB,kDAAkD;IAClD,QAAS,CAAC,EAAE,OAAO,GAAG,QAAQ,GAAG,KAAK,GAAG,SAAS,CAAC;CACnD,CAAA;AAED;;;;;;;;;;;;;;;;;;GAkBG;AACH,MAAM,UAAU,sBAAsB,CACrC,cAAc,EAAG,MAAM,EACvB,iBAAiB,EAAG,MAAM,EAC1B,aAAa,EAAG,MAAM,EACtB,gBAAgB,EAAG,MAAM,EACzB,OAAO,EAAG,qBAAqB,GAAG,EAAE,yBAAA,GACjC,MAAM;IACT,IAAI,EAAE,WAAW,GAAG,CAAC,EAAE,SAAS,GAAG,CAAC,EAAE,QAAQ,GAAG,SAAS,EAAC,GAAG,OAAO,CAAC;IAEtE,kBAAkB;IAClB,MAAM,0BAA0B,GAAG,gBAAgB,GAAG,iBAAiB,GAAG,WAAW,CAAC;IACtF,MAAM,6BAA6B,GAClC,gBAAgB;QAChB,aAAa;QACb,iBAAiB;QACjB,cAAc;QACd,SAAS,CAAC;IAEX,yBAAyB;IACzB,IAAI,QAAQ,IAAI,SAAS,EAAE;QAC1B,IAAI,0BAA0B,IAAI,CAAC,IAAI,6BAA6B,IAAI,CAAC,EAAE;YAC1E,OAAO,iBAAiB,CAAC;SACzB;QACD,QAAQ;YACP,IAAI,CAAC,GAAG,CAAC,0BAA0B,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,6BAA6B,CAAC;gBAC7E,CAAC,CAAC,KAAK;gBACP,CAAC,CAAC,OAAO,CAAC;KACZ;IAED,oBAAoB;IACpB,IAAI,aAAa,GAAG,CAAC,CAAC;IACtB,QAAQ,QAAQ,EAAE;QACjB,KAAK,OAAO;YACX,0BAA0B;YAC1B,aAAa,GAAG,gBAAgB,GAAG,WAAW,CAAC;YAC/C,MAAM;QACP,KAAK,QAAQ;YACZ,0BAA0B;YAC1B,aAAa;gBACZ,gBAAgB;oBAChB,CAAC,cAAc,GAAG,aAAa,GAAG,SAAS,GAAG,WAAW,CAAC,GAAG,CAAC;oBAC9D,WAAW,CAAC;YACb,MAAM;QACP,KAAK,KAAK;YACT,0BAA0B;YAC1B,aAAa;gBACZ,gBAAgB,GAAG,aAAa,GAAG,cAAc,GAAG,SAAS,CAAC;YAC/D,MAAM;KACP;IAED,OAAO,aAAa,CAAC;AACtB,CAAC","sourcesContent":["// @ts-nocheck\n\n// export * from './uvue.uts'\nexport { getRect, getAllRect } from './uvue.uts'\n\n\n\n\n\n\n\n\n\n\n/**\n * 获取视口滚动条位置信息\n */\nexport function getViewportScrollInfo() : Promise<any> {\n\treturn new Promise(resolve => {\n\t\tuni.createSelectorQuery()\n\t\t\t.selectViewport()\n\t\t\t.scrollOffset((res) => {\n\t\t\t\tresolve(res);\n\t\t\t}).exec();\n\t})\n}\n\n/**\n```\n                      page\n                     ╱\n    ╭───────────────╮    viewport\n  ╭─│─ ─ ─ ─ ─ ─ ─ ─│─╮ ╱\n  │ │ ╭───────────╮ │ │\n  │ │ │  element  │ │ │\n  │ │ ╰───────────╯ │ │\n  ╰─│─ ─ ─ ─ ─ ─ ─ ─│─╯\n    │               │\n    │               │\n    ╰───────────────╯\n```\n\n# 参数\n- viewportHeight: viewport 高度\n- viewportScrollTop: viewport 垂直滚动值\n- elementHeight: element 高度\n- elementOffsetTop: element 距离页面顶部距离\n\n# 选项\n- position: element 在视窗中的位置(start, center, end, nearest)\n- startOffset: element 距离视窗顶部的偏移量\n- endOffset: element 距离视窗底部的偏移量\n\n# 结果值\n- viewportScrollTop: viewport 新的垂直滚动值\n\n*/\n\nexport type ScrollIntoViewOptions = {\n\t/** 元素顶部需要保留的缓冲距离（默认 0） */\n\tstartOffset ?: number;\n\t/** 元素底部需要保留的缓冲距离（默认 0） */\n\tendOffset ?: number;\n\t/** 滚动对齐方式：start/center/end/nearest（默认 nearest） */\n\tposition ?: 'start' | 'center' | 'end' | 'nearest';\n}\n\n/**\n * 计算元素需要滚动到可视区域的目标滚动位置\n * @param viewportHeight 视口高度（像素）\n * @param viewportScrollTop 当前滚动位置（像素）\n * @param elementHeight 元素高度（像素）\n * @param elementOffsetTop 元素相对于父容器顶部的偏移量（像素）\n * @param options 配置选项\n * @returns 计算后的目标滚动位置（像素）\n *\n * @example\n * // 示例：将元素滚动到视口顶部对齐\n * const scrollTop = getScrollIntoViewValue(\n *   500,  // 视口高度\n *   200,  // 当前滚动位置\n *   100,  // 元素高度\n *   300,  // 元素偏移量\n *   { position: 'start' }\n * );\n */\nexport function getScrollIntoViewValue(\n\tviewportHeight : number,\n\tviewportScrollTop : number,\n\telementHeight : number,\n\telementOffsetTop : number,\n\toptions : ScrollIntoViewOptions = {}\n) : number {\n\tlet { startOffset = 0, endOffset = 0, position = 'nearest'} = options;\n\n\t// 计算元素相对于视口的上下偏移量\n\tconst elementToViewportTopOffset = elementOffsetTop - viewportScrollTop - startOffset;\n\tconst elementToViewportBottomOffset =\n\t\telementOffsetTop +\n\t\telementHeight -\n\t\tviewportScrollTop -\n\t\tviewportHeight +\n\t\tendOffset;\n\n\t// 处理 nearest 模式，自动选择最近边缘\n\tif (position == 'nearest') {\n\t\tif (elementToViewportTopOffset >= 0 && elementToViewportBottomOffset <= 0) {\n\t\t\treturn viewportScrollTop;\n\t\t}\n\t\tposition =\n\t\t\tMath.abs(elementToViewportTopOffset) > Math.abs(elementToViewportBottomOffset)\n\t\t\t\t? 'end'\n\t\t\t\t: 'start';\n\t}\n\n\t// 根据不同的对齐位置计算目标滚动位置\n\tlet nextScrollTop = 0;\n\tswitch (position) {\n\t\tcase 'start':\n\t\t\t// 顶部对齐：元素顶部对齐视口顶部（考虑顶部缓冲）\n\t\t\tnextScrollTop = elementOffsetTop - startOffset;\n\t\t\tbreak;\n\t\tcase 'center':\n\t\t\t// 居中对齐：元素中心对齐视口中心（考虑上下缓冲）\n\t\t\tnextScrollTop =\n\t\t\t\telementOffsetTop -\n\t\t\t\t(viewportHeight - elementHeight - endOffset - startOffset) / 2 +\n\t\t\t\tstartOffset;\n\t\t\tbreak;\n\t\tcase 'end':\n\t\t\t// 底部对齐：元素底部对齐视口底部（考虑底部缓冲）\n\t\t\tnextScrollTop =\n\t\t\t\telementOffsetTop + elementHeight - viewportHeight + endOffset;\n\t\t\tbreak;\n\t}\n\n\treturn nextScrollTop;\n}"]}