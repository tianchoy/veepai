{"version":3,"file":"utils.js","sources":["uni_modules/lime-date-time-picker/components/l-date-time-picker/utils.ts"],"sourcesContent":["// @ts-nocheck\r\nimport { TimeModeValues } from './type';\r\nimport { MODE_NAMES, MODE_MAP, MODE_YEAR, MODE_MONTH, MODE_DATE, MODE_HOUR, MODE_MINUTE, MODE_SECOND } from './constant'\r\n\r\n\r\n/**\r\n * 根据给定的模式返回具有意义的时间列数组。\r\n * @param {number} mode - 表示时间模式的位掩码。\r\n * @returns {TimeModeValues[]} - 返回具有意义的时间列名称数组。\r\n */\r\nexport function getMeaningColumn(mode : any) : TimeModeValues[] {\r\n\t// 初始化结果数组\r\n\tconst res : TimeModeValues[] = [];\r\n\t\r\n\tlet _mode:number = 0;\r\n\tif(typeof mode == 'string') {\r\n\t\tMODE_MAP.forEach((value, key) => {\r\n\t\t\tif((mode as string).includes(key)) {\r\n\t\t\t\t_mode = _mode | value;\r\n\t\t\t}\r\n\t\t})\r\n\t} else if(typeof mode == 'number') {\r\n\t\t_mode = mode as number\r\n\t}\r\n\t\r\n\tif(_mode <= 0) {\r\n\t\treturn res\r\n\t}\r\n\t\r\n\r\n\t// 定义对应的位掩码数组\r\n\tconst modeBitmasks = [MODE_YEAR, MODE_MONTH, MODE_DATE, MODE_HOUR, MODE_MINUTE, MODE_SECOND];\r\n\r\n\t// 查找被设置的位掩码\r\n\tconst activeBitmasks = modeBitmasks.filter(bitmask => (_mode & bitmask) != 0);\r\n\r\n\t// 如果没有位掩码被设置，返回空数组\r\n\tif (activeBitmasks.length == 0) {\r\n\t\treturn [];\r\n\t}\r\n\r\n\t// 初始化最长连续子序列和当前连续子序列\r\n\tlet longestSequence : number[] = [];\r\n\tlet currentSequence : number[] = [];\r\n\r\n\t// 遍历所有被设置的位掩码\r\n\tactiveBitmasks.forEach(bitmask => {\r\n\t\t// 如果当前序列为空或当前位掩码是前一个位掩码的两倍，则将其加入当前序列\r\n\t\tif (currentSequence.length == 0 || bitmask == currentSequence[currentSequence.length - 1] * 2) {\r\n\t\t\tcurrentSequence.push(bitmask);\r\n\t\t} else {\r\n\t\t\t// 如果当前序列长度大于最长序列长度，则更新最长序列\r\n\t\t\tif (currentSequence.length > longestSequence.length) {\r\n\t\t\t\tlongestSequence = currentSequence;\r\n\t\t\t}\r\n\t\t\t// 开始新的序列\r\n\t\t\tcurrentSequence = [bitmask];\r\n\t\t}\r\n\t});\r\n\r\n\t// 检查最后一个序列是否是最长的\r\n\tif (currentSequence.length > longestSequence.length) {\r\n\t\tlongestSequence = currentSequence;\r\n\t}\r\n\r\n\t// 将最长连续子序列的位掩码转换为对应的模式名并返回\r\n\treturn longestSequence.map(bitmask => MODE_NAMES[modeBitmasks.indexOf(bitmask)]);\r\n}"],"names":["MODE_MAP","MODE_YEAR","MODE_MONTH","MODE_DATE","MODE_HOUR","MODE_MINUTE","MODE_SECOND","MODE_NAMES"],"mappings":";;AAUM,SAAU,iBAAiB,MAAU;AAE1C,QAAM,MAAyB,CAAA;AAE/B,MAAI,QAAe;AACnB,MAAG,OAAO,QAAQ,UAAU;AAC3BA,uEAAAA,SAAS,QAAQ,CAAC,OAAO,QAAG;AAC3B,UAAI,KAAgB,SAAS,GAAG,GAAG;AAClC,gBAAQ,QAAQ;AAAA,MAChB;AAAA,IACF,CAAC;AAAA,EACD,WAAS,OAAO,QAAQ,UAAU;AAClC,YAAQ;AAAA,EACR;AAED,MAAG,SAAS,GAAG;AACd,WAAO;AAAA,EACP;AAID,QAAM,eAAe,CAACC,mEAAAA,WAAWC,mEAAU,YAAEC,mEAAS,WAAEC,8EAAWC,mEAAAA,aAAaC,mEAAAA,WAAW;AAG3F,QAAM,iBAAiB,aAAa,OAAO,aAAW;AAAA,YAAC,QAAQ,YAAY;AAAA,EAArB,CAAsB;AAG5E,MAAI,eAAe,UAAU,GAAG;AAC/B,WAAO;EACP;AAGD,MAAI,kBAA6B,CAAA;AACjC,MAAI,kBAA6B,CAAA;AAGjC,iBAAe,QAAQ,aAAO;AAE7B,QAAI,gBAAgB,UAAU,KAAK,WAAW,gBAAgB,gBAAgB,SAAS,CAAC,IAAI,GAAG;AAC9F,sBAAgB,KAAK,OAAO;AAAA,IAC5B,OAAM;AAEN,UAAI,gBAAgB,SAAS,gBAAgB,QAAQ;AACpD,0BAAkB;AAAA,MAClB;AAED,wBAAkB,CAAC,OAAO;AAAA,IAC1B;AAAA,EACF,CAAC;AAGD,MAAI,gBAAgB,SAAS,gBAAgB,QAAQ;AACpD,sBAAkB;AAAA,EAClB;AAGD,SAAO,gBAAgB,IAAI,aAAO;AAAI,WAAAC,mEAAAA,WAAW,aAAa,QAAQ,OAAO,CAAC;AAAA,EAAC,CAAA;AAChF;;"}