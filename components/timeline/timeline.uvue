<template>
  <view class="timeline-container" @touchstart="onTouchStart" @touchmove="onTouchMove" @touchend="onTouchEnd">
    <!-- 使用ref代替canvas-id -->
    <canvas ref="timelineCanvas" class="timeline-canvas"></canvas>
    
    <view class="scrubber" :style="{ left: scrubberPosition + 'px' }">
      <view class="scrubber-line"></view>
      <view class="scrubber-handle"></view>
    </view>
    
    <view v-if="isDragging" class="time-preview" :style="{ left: (scrubberPosition - 30) + 'px' }">
      {{ formatTime(currentTime) }}
    </view>
  </view>
</template>

<script lang="uts" setup>
import { ref, watch, onMounted } from 'vue'

// 定义Canvas引用类型
declare interface UniCanvas extends HTMLElement {
  getContext(contextId: '2d'): CanvasRenderingContext2D | null;
}

interface EventMarker {
  time: number
  color: string
}

const props = defineProps<{
  totalDuration?: number
  currentTime?: number
  eventMarkers?: EventMarker[]
}>()

const emit = defineEmits(['seek', 'onDragStart', 'onDragEnd'])

const containerWidth = ref(300)
const scrubberPosition = ref(0)
const isDragging = ref(false)

// 使用正确的Canvas引用类型
const timelineCanvas = ref<UniCanvas>()  // 通过ref获取canvas节点
let canvasContext: CanvasRenderingContext2D | null = null

const drawTimeline = () => {
  // 使用 == null 检查替代 ! 操作符
  if (canvasContext == null) return
  
  // Canvas方法现在可用
  canvasContext.clearRect(0, 0, containerWidth.value, 50)
  
  // 背景轨道绘制
  canvasContext.fillStyle = '#333'
  canvasContext.fillRect(0, 15, containerWidth.value, 10)
  
  // 时间刻度绘制
  const hours = Math.ceil(props.totalDuration || 0 / 3600)
  for (let i = 0; i <= hours * 6; i++) {
    const time = i * 600
    const pos = timeToPosition(time)
    
    if (i % 3 === 0) {
      canvasContext.fillStyle = '#fff'
      canvasContext.fillRect(pos, 5, 2, 25)
      
      // 文本绘制方法调整
      canvasContext.font = '10px sans-serif'
      canvasContext.fillText(formatTime(time), pos - 15, 40)
    } else {
      canvasContext.fillStyle = '#aaa'
      canvasContext.fillRect(pos, 15, 1, 15)
    }
  }
  
  // 事件标记点绘制
  props.eventMarkers?.forEach((marker: EventMarker) => {
    const pos = timeToPosition(marker.time)
    canvasContext.fillStyle = marker.color
    canvasContext.fillRect(pos - 2, 10, 4, 20)
  })
  
  // 不需要draw()方法，canvas自动渲染
  updateScrubberPosition()
}

const updateScrubberPosition = () => {
  scrubberPosition.value = timeToPosition(props.currentTime || 0)
}

const timeToPosition = (time: number): number => {
  if (!props.totalDuration || props.totalDuration <= 0) return 0
  return Math.min((time / props.totalDuration) * containerWidth.value, containerWidth.value)
}

const positionToTime = (pos: number): number => {
  return (pos / containerWidth.value) * (props.totalDuration || 0)
}

const formatTime = (seconds: number): string => {
  const hrs = Math.floor(seconds / 3600)
  const mins = Math.floor((seconds % 3600) / 60)
  const secs = Math.floor(seconds % 60)
  return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
}

// 重构initCanvas函数 - 通过ref获取上下文
const initCanvas = () => {
  if (timelineCanvas.value == null) return
  canvasContext = timelineCanvas.value.getContext('2d')
  if (canvasContext) drawTimeline()
}

const onTouchStart = (e: TouchEvent) => {
  isDragging.value = true
  emit('onDragStart')
  handleTouch(e)
}

const onTouchMove = (e: TouchEvent) => {
  if (!isDragging.value) return
  handleTouch(e)
}

const onTouchEnd = (e: TouchEvent) => {
  if (!isDragging.value) return
  isDragging.value = false
  handleTouch(e)
  emit('onDragEnd', props.currentTime)
}

const handleTouch = (e: TouchEvent) => {
  const touch = e.touches?.[0] || e.changedTouches?.[0]
  if (!touch) return
  
  uni.createSelectorQuery()
    .select('.timeline-container')
    .boundingClientRect((rect: any) => {
      if (rect) {
        const pos = Math.max(0, Math.min(touch.clientX - rect.left, containerWidth.value))
        scrubberPosition.value = pos
        const seekTime = positionToTime(pos)
        emit('seek', seekTime)
      }
    })
    .exec()
}

onMounted(() => {
  uni.createSelectorQuery()
    .select('.timeline-container')
    .boundingClientRect((rect: any) => {
      if (rect) {
        containerWidth.value = rect.width
        initCanvas()
      }
    })
    .exec()
})

watch(() => props.currentTime, (newVal) => {
  if (!isDragging.value && newVal != null) {
    scrubberPosition.value = timeToPosition(newVal)
  }
})

watch(() => props.totalDuration, () => {
  drawTimeline()
})

defineExpose({
  drawTimeline
})
</script>

<style scoped>
.timeline-container {
  width: 100%;
  height: 60px;
  position: relative;
  background-color: #222;
}

.timeline-canvas {
  width: 100%;
  height: 50px;
  position: absolute;
  top: 5px;
}

.scrubber {
  position: absolute;
  top: 0;
  height: 100%;
  width: 2px;
  background-color: red;
  transform: translateX(-50%);
  pointer-events: none;
}

.scrubber-handle {
  position: absolute;
  top: -5px;
  left: 50%;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background-color: red;
  transform: translateX(-50%);
}

.time-preview {
  position: absolute;
  bottom: 65px;
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 5px 10px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
}
</style>